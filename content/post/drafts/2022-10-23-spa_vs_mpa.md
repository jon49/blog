---
url: /mpa-vs-spa/
date: 2022-10-23
title: MPA vs SPA
tags:
  - mpa
  - spa
  - comparison
series: MPA
draft: true
---

## Introduction

In this series I'm going to explore MPAs and how to make them better without
going down the traditional SPA route. How to make web apps simply but have the
full power of an SPA without its complexity.

## What is an MPA

An MPA is a _Multiple web page application_. MPAs serve their content from a
server and render HTML on the front end. Each page performs a single domain
function. When a form is submitted then the whole page is refreshed or an
`iframe` is updated using native HTML.

## What is an SPA

SPAs will combine multiple domains and have a singe user experience across
multiple pages on a website. The page transitions will be more polished. Some
data might be cached.

## Comparison

### Development

MPAs tend to be simpler to work with as they use a templating system and are
one-to-one to the web pages that they are related to. Also, those pages tend to
be simpler also, since the pages tend to be more single purpose. They can become
complex on the back end if the developers don't break of the templates into
separate templates and use them for more than one purpose. When adding a lot of
dynamic content to a page the complexity goes up significantly.

With a SPA a developer can more easily be tempted to start putting too much into
a single page. This creates a lot of complexity.

### Browser Built-Ins

With an MPA developers will tend to use native HTML constructs more. E.g., the
`details` and `summary` tags rather than reimplementing a hide and show. This
makes it harder to break the browser and make it more difficult for the users to
use the web page. Another example of this would be history. It is much more
difficult to reimplement history correctly rather than just using the browser to
handle history.

### Graceful Degradation (Progressive Enhancement)

MPAs handle graceful degradation better as they rely native HTML constructs more
and then add JavaScript for any bonus interactions. SPAs cannot have graceful
degradation as they rely on JavaScript for everything, so JS cannot be turned
off. New frameworks which are complex are trying to overcome this problem for
SPAs, but this could be done simpler by starting from the back end to begin
with.

### State Management

State management with an MPA can be very difficult and overly complex. Solutions
to this problem can be putting state in an in-memory database like Redis or
other caching mechanism. The data can be pushed to the server on every post and
re-rendered in HTML. It can be put in cookies. If it is local state then a web
component could be used, but you would need to be careful about graceful
degradation mentioned above. Most of the state in an MPA would be embedded in
the HTML itself.

Whereas in a SPA state it is much easier to handle. A problem to be careful of
with SPAs is adding unnecessary state to the front end. State in a SPA can be in
many places, e.g., JSON, JavaScript, front end database (Local Storage, etc.).

Some developers have advocated for syncing part of the database from the back
end to the front end — this is a highly complex and dangerous to data integrity
way to do things. It might make sense to do this for offline applications but
for applications which require the user to know that the data has been saved on
the back end and the data on the front end is the most recent data then it
wouldn't make sense to follow that pattern — most users would prefer to wait for
the data to be saved before moving on to the next task.



| Limited interactivity as a new page is typically required.                    | It's as interactive as you would like! Note, this can be a bad thing as it become too complex.                                                   |


| MPA                                                                           | SPA                                                                                                                                              |
| :---                                                                          | :---                                                                                                                                             |
| Great first load.                                                             | Slow first load time.                                                                                                                            |
| Works well for screen readers.                                                | Requires extra care for screen readers.                                                                                                          |
| Janky page transitions.                                                       | Smooth page transitions.                                                                                                                         |
| Easy to program in your favorite programming language.                        | Can be difficult as keeping track of state on the front end gets complicated.                                                                    |
| Low memory usage.                                                             | high memory usage.                                                                                                                               |
| Low CPU.                                                                      | Higher CPU usage.                                                                                                                                |
| Good for low-end devices.                                                     | Can be bad for low-end devices.                                                                                                                  |
| Tracking client state is difficult.                                           | Tracking client state is simplified.                                                                                                             |
| SEO is simple.                                                                | SEO is difficult, it might require back end static rendering.                                                                                    |
| Business rules live on the back end.                                          | Business rules can be exposed on the front end or duplicated on the front end.                                                                   |
| Permissions for data are easier to not expose unauthorized information.       | If not extremely careful unauthorized data can be exposed in the clien in `JSON` objects.                                                        |
| Second renders can be slow.                                                   | Second renders are normally fast.                                                                                                                |
| Mobile development doesn't allow for code reuse.                              | Mobile development may reuse some of the code.                                                                                                   |
| Can be used without JavaScript.                                               | Requires JavaScript to be enabled.                                                                                                               |
| More secure.                                                                  | Less secure unless the developers are very careful.                                                                                              |
| Memory leaks are less likely.                                                 | Memory leaks are possible.                                                                                                                       |
| No need to reimplement browser constructs.                                    | You need to reimplement built-in browser technology, like history, go back to same spot on page when opening page after browser was closed, etc. |
| Separation of concerns (each page is typically made to be focused and small). | Different concerns can be mixxed, making it difficult to understand.                                                                             |
| Navigating between pages requires a full refresh hurting the user experience. | Navigation between pages is more seemless.                                                                                                       |

## Sources

[Single-page applications vs. multiple-page applications: pros, cons,
pitfalls](https://archive.ph/61iEB)

