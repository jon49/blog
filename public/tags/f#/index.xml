<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>F# on Hamsters Byte</title>
    <link>http://localhost:1313/tags/f/</link>
    <description>Recent content in F# on Hamsters Byte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Feb 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/f" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Power of Static Typing</title>
      <link>http://localhost:1313/2017/02/12/the_power_of_static_typing/</link>
      <pubDate>Sun, 12 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2017/02/12/the_power_of_static_typing/</guid>
      <description>&lt;p&gt;From what I understand &lt;a href=&#34;http://www.cs.cmu.edu/~NatProg/papers/CHI2016-SIG-ProgLang-Usability.pdf&#34;&gt;static typing makes programmers more productive and
gives implicit documentation to the code
base&lt;/a&gt;
- although explicit documentation is also very helpful.  It also seems to make
the tools we use much more powerful.&lt;/p&gt;

&lt;p&gt;One of the problems of static typing is that your code becomes more verbose.
With programming languages like F# the compiler will implicitly type as much
of your program as possible. Where it fails, you need to type it yourself.&lt;/p&gt;

&lt;p&gt;Not only that but many times static languages will provide tools to do the
typing for you. F# has &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/&#34;&gt;Type
Providers&lt;/a&gt;
which will dynamically create types for your program on the fly, lessening the
burdens of a statically typed system. One of my favorite libraries that does
this is &lt;a href=&#34;http://fsprojects.github.io/FSharp.Data.SqlClient/&#34;&gt;&lt;code&gt;FSharp.Data.SqlClient&lt;/code&gt; - &lt;em&gt;Not your grandfather&amp;rsquo;s
ORM&lt;/em&gt;&lt;/a&gt; which will
statically type your calls to SQL Server letting you even type raw SQL in your
code. Another useful one is the &lt;a href=&#34;http://fsharp.github.io/FSharp.Data/library/JsonProvider.html&#34;&gt;JSON Type
Provider&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With F#, &lt;a href=&#34;http://websharper.com/&#34;&gt;WebSharper&lt;/a&gt;, and &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/hh272686%28v=vs.103%29.aspx&#34;&gt;SQL Server Data
Tools&lt;/a&gt;(SSDT)
you can have static typing from your database all the way down to your client
web app. You can literally keep everything in sync with each other from across
your entire infrastructure. This seems really huge to me. Programming in any
other way seems like programming in the past, by decades. Unfortunately, it
seems like it takes ages for the programming community and business industry
to get on board. It is understandable and mind boggling at the same time.&lt;/p&gt;

&lt;p&gt;So, SSDT, can give you static typing across databases, it seems to work best
when they live on the same server when you track the databases in the same
SSDT solution. But you can also have this static typing across different
servers in different SSDT solutions by referencing the &lt;code&gt;dacpac&lt;/code&gt; of the
different databases you are connecting to. It also makes testing much simpler
with the help of &lt;a href=&#34;http://tsqlt.org/&#34;&gt;&lt;code&gt;tSQLt&lt;/code&gt;&lt;/a&gt; testing framework.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve never used &lt;a href=&#34;http://websharper.com/&#34;&gt;WebSharper&lt;/a&gt; before but it looks like
it is a wonderful way to write your back end and front end code. I&amp;rsquo;m not sure
if other .NET frameworks can give you the same static typing that WebSharper
can, but &lt;a href=&#34;http://websharper.com/blog-entry/5204/distributed-web-applications-in-f-with-websharper&#34;&gt;WebSharper can generate your end points for you in distributed
applications, letting them be private or public end
points&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, with all this incredible technology that can make us so much more
productive why do we not embrace this technology and stop doing the computer&amp;rsquo;s
work for it? I&amp;rsquo;m sure there are many reasons, including psychology and
business maintainability. Which I won&amp;rsquo;t enumerate some here, which I
think could possibly be reasons. Let&amp;rsquo;s start embracing this technology and
start slowly introducing them where we can in are work places. It might take
another ten or twenty years to be able to really start letting the computer do
its work rather than us doing its work, but the time to start planting the
seeds is now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# with Web API and Railway-Oriented Programming</title>
      <link>http://localhost:1313/2016/12/04/fsharp_with_webapi/</link>
      <pubDate>Sun, 04 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2016/12/04/fsharp_with_webapi/</guid>
      <description>

&lt;p&gt;I presented at the &lt;a href=&#34;http://oct2016.desertcodecamp.com/session/1224&#34;&gt;2016 Desert Code
Camp&lt;/a&gt;. The topic was &lt;em&gt;WebAPI
with F#&lt;/em&gt;. I also did a video series to go along with the talk. The talk and
video series basically goes over how to use F# in a functional manner by
building out all the pieces from scratch.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the series, hope you enjoy it!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLBrr7-AbuzAfeA4vVhHEDsaAPBep2SUVI&#34;&gt;F# WebAPI From Start to
Finish&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some set up steps and notes that are important to the success of the project:&lt;/p&gt;

&lt;p&gt;Rather than using a custom Railway-Oriented code like in the videos you can use
&lt;a href=&#34;https://fsprojects.github.io/Chessie/railway.html&#34;&gt;Chessie&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jnyman.com/2016/11/27/validation_in_fsharp/&#34;&gt;I&amp;rsquo;ve updated my validation library.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;setting-up-your-project:b907d02c7024fd468e4e916e6de9753a&#34;&gt;Setting Up Your Project&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/136b942e-9f2c-4c0b-8bac-86d774189cff&#34;&gt;Install Visual F# Power Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create new C# WebAPI&lt;/li&gt;
&lt;li&gt;Create new F# Library&lt;/li&gt;
&lt;li&gt;Add reference to F# Library from C# project.&lt;/li&gt;
&lt;li&gt;Make sure works&lt;/li&gt;
&lt;li&gt;Add reference to System.Net.Http&lt;/li&gt;
&lt;li&gt;Add reference to System.Web.Http &amp;rarr; Need to install Nuget package
Microsoft.AspNet.WebApi.Core&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ploeh.dk/2015/03/19/posting-json-to-an-f-web-api/&#34;&gt;Add configuration&lt;/a&gt;
&amp;rarr;
&lt;code&gt;GlobalConfiguration.Configuration.Formatters.JsonFormatter.SerializerSettings.ContractResolver = new Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eulerfx/JsonNet.FSharp&#34;&gt;Add FSharp Converters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Configuration

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fsharp.github.io/FSharp.Data/library/JsonProvider.html&#34;&gt;JsonProvider&lt;/a&gt;
&amp;rarr; Use FSharp.Data from Nuget&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Connecting to a database using
&lt;a href=&#34;http://fsprojects.github.io/FSharp.Data.SqlClient/&#34;&gt;FSharp.Data.SqlClient&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;resources-for-railway-oriented-programming:b907d02c7024fd468e4e916e6de9753a&#34;&gt;Resources for Railway-Oriented Programming&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fsharpforfunandprofit.com/rop/&#34;&gt;https://fsharpforfunandprofit.com/rop/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://fsharpforfunandprofit.com/posts/recipe-part2/&#34;&gt;https://fsharpforfunandprofit.com/posts/recipe-part2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Validation in F#</title>
      <link>http://localhost:1313/2016/11/27/validation_in_fsharp/</link>
      <pubDate>Sun, 27 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2016/11/27/validation_in_fsharp/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gist.github.com/jon49/c2835a9c85b43036323547dc3706ebd2&#34;&gt;The full code for this article is up on GitHub.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I like to the keep things as simple as possible and, ideally, reusable. At my
previous employment I came up with a method of validation, but I was never
entirely happy with the results. Some of the code repeated itself, and it was
difficult to extend to arrays and array comparison. So, I went back to the
drawing board building on top of the ideas that I created with the first
validation library I created.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how the original API looked:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;validate &amp;quot;Name&amp;quot; a.Name [nonEmptyString]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, you needed to add the name of your property, the property, and a list of
validators you would like to validate. The list of validators would return a
&lt;code&gt;Choice&amp;lt;string, &#39;a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The new validation has a pretty straight forward API that is used throughout.
You can validate against an &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Primitive&lt;/code&gt;, or &lt;code&gt;Raw&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Object&lt;/code&gt; validation validates against each property in a &lt;code&gt;Record&lt;/code&gt;. If one
fails then it will continue to validate the other properties also. But if
there are multiple validators on a single property the first failure will
return but not the others. &lt;code&gt;Object&lt;/code&gt; has the following signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;| Object of
    value : Expr&amp;lt;&#39;a&amp;gt; *
    required : bool *
    proof : (&#39;a -&amp;gt; (string list option) list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;value&lt;/code&gt; is the quotation value of the property you are testing.
&lt;code&gt;required&lt;/code&gt; tests if the property is &lt;code&gt;null&lt;/code&gt; or not if you mark it as true,
otherwise it doesn&amp;rsquo;t care if it is &lt;code&gt;null&lt;/code&gt; or not. &lt;code&gt;proof&lt;/code&gt; is the list of
provided validators. A single validator has the signature
&lt;code&gt;a -&amp;gt; string option&lt;/code&gt;. If the property is valid the validator returns &lt;code&gt;None&lt;/code&gt;
otherwise it returns &lt;code&gt;Some&lt;/code&gt; with a message describing why it didn&amp;rsquo;t pass
validation.&lt;/p&gt;

&lt;p&gt;I like this way of validating since it keeps things simple. The validators are
reusable functions which return a simple &lt;code&gt;string option&lt;/code&gt;. The validators are
composable functions that can be put in a list. The discriminated union
validation object is also composable.&lt;/p&gt;

&lt;p&gt;Some things that I don&amp;rsquo;t like about validating this way. There is no compile
time check to determine if you validated each field in an object. For that
matter there is no runtime test for that either. It would be nice to have a
least a runtime way to tell if all properties were tested, or, even better, a
compile time way. But this works for now.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of using all the validators in with an object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person =
    {
    Name : Name
    BirthDate : DateTime
    Favorites : string[]
    FavoriteNumbers : int[]
    }
    static member Proof a =
                [
                prove &amp;lt;| Primitive (&amp;lt;@ a.BirthDate @&amp;gt;, true, [])
                prove &amp;lt;| Object (&amp;lt;@ a.Name @&amp;gt;, true, Name.Proof)
                prove &amp;lt;|
                    Array (
                        &amp;lt;@ a.Favorites @&amp;gt;,
                        true,
                        [arrayMinLength 1],
                        (fun favorite -&amp;gt; Primitive (&amp;lt;@ favorite @&amp;gt;, true, [stringMax 5]) ))
                prove &amp;lt;|
                    Array (
                        &amp;lt;@ a.FavoriteNumbers @&amp;gt;,
                        true,
                        [arrayMinLength 1],
                        fun favorite -&amp;gt; Primitive (&amp;lt;@ favorite @&amp;gt;, true, [greaterThan 2])
                    )
                prove &amp;lt;|
                    Raw (
                        (a.Favorites, a.FavoriteNumbers),
                        &amp;quot;Person.Favorites, Person.FavoriteNumbers&amp;quot;,
                        [
                        fun (a, b) -&amp;gt;
                            match a, b with
                            | null, null | null, _ | _, null -&amp;gt; Some &amp;quot;Arrays must not be null.&amp;quot;
                            | _ -&amp;gt; None
                        fun (a, b) -&amp;gt;
                            if a.Length = b.Length then
                                None
                            else
                                Some &amp;lt;| sprintf &amp;quot;Arrays must have same length but Person.Favorites has %i and Person.FavoriteNumbers has %i&amp;quot; a.Length b.Length
                        ]
                    )
                ]
    static member Validate a =
        prove &amp;lt;| Object (&amp;lt;@ a @&amp;gt;, true, Person.Proof)

let jon = {
    Name = { First = &amp;quot;Jon&amp;quot;; Last = &amp;quot;Nyman1&amp;quot; }
    BirthDate = new DateTime(1947, 9, 9)
    Favorites = [| &amp;quot;Reading&amp;quot;; &amp;quot;Red&amp;quot;;  &amp;quot;Writing&amp;quot; |]
    FavoriteNumbers = [| 1 |]
    }

jon
|&amp;gt; validate Person.Validate
// |&amp;gt; ....

// OR
jon
|&amp;gt; validate (fun a -&amp;gt; prove &amp;lt;| Object (&amp;lt;@ a @&amp;gt;, true, Person.Proof))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;prove&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec prove validation =
    match validation with
    | Primitive (v, required, fs) -&amp;gt;
        match required, getValue v with
        | true, None -&amp;gt; Some [sprintf &amp;quot;The value `%s` is required but was found to be `null`.&amp;quot; v.Type.Name]
        | false, None -&amp;gt; None
        | _, Some value -&amp;gt;
            fs
            |&amp;gt; List.fold (fun acc f -&amp;gt;
                match acc with
                | None -&amp;gt; f value
                | Some _ -&amp;gt; acc
                ) None
            |&amp;gt; Option.map (fun x -&amp;gt; [printParameterWith &amp;quot; - &amp;quot; v + x] )
    | Object (v, required, f) -&amp;gt;
        match required, getValue v with
        | true, None -&amp;gt; Some [sprintf &amp;quot;The object `%s` is required but was found to be `null`.&amp;quot; (getOrElse &amp;quot;Unknown Parameter&amp;quot; &amp;lt;| getParameterName v)]
        | false, None -&amp;gt; None
        | _, Some x -&amp;gt;
            f x
            |&amp;gt; List.fold (
                fun acc option -&amp;gt;
                match option, acc with
                | Some newError, Some error -&amp;gt; Some (List.append error newError)
                | Some newError, None -&amp;gt; Some newError
                | None, Some error -&amp;gt; Some error
                | None, None -&amp;gt; None
                ) None
    | Array (vs, required, proof, proveItems) -&amp;gt; 
        match required, getValue vs with
        | true, None -&amp;gt; Some [sprintf &amp;quot;%s: %s&amp;quot; (getOrElse &amp;quot;Unknown Parameter&amp;quot; &amp;lt;| getParameterName vs) &amp;quot;This array is required.&amp;quot;]
        | false, None -&amp;gt; None
        | _, Some xs -&amp;gt;
            let validSelf =
                proof
                |&amp;gt; List.fold (fun acc f -&amp;gt;
                    match acc with
                    | None -&amp;gt; f xs
                    | Some _ -&amp;gt; acc
                ) None
            match validSelf, obj.Equals(vs, null) with
            | Some error, _ -&amp;gt; 
                Some [(printParameterWith &amp;quot;: &amp;quot; vs) + error]
            | _, true -&amp;gt;
                None
            | None, false -&amp;gt;
                xs
                |&amp;gt; Array.fold (fun (i, acc) x -&amp;gt;
                    let i = i + 1
                    match (prove (proveItems x) ), acc with
                    | Some newError, Some error -&amp;gt; 
                        (i, Some &amp;lt;| List.append error [prettyIndex i newError])
                    | Some newError, None -&amp;gt; (i, Some [prettyIndex i newError])
                    | None, Some error -&amp;gt; (i, Some error)
                    | None, None -&amp;gt; (i, None)
                ) (-1, None)
                |&amp;gt; snd
                |&amp;gt; Option.map (fun xs -&amp;gt; (printParameterWith &amp;quot;:&amp;quot; vs)::xs)
    | Raw (a, msg, fs) -&amp;gt;
        fs
        |&amp;gt; List.fold (fun acc f -&amp;gt;
            match acc with
            | None -&amp;gt; f a
            | Some _ -&amp;gt; acc
            ) None
        |&amp;gt; Option.map (fun x -&amp;gt; [msg+&amp;quot; - &amp;quot;+x] )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;validate&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let validate f a =
    match f a with
    | Some xs -&amp;gt; Choice1Of2 &amp;lt;| String.concat &amp;quot;\n&amp;quot; xs
    | None -&amp;gt; Choice2Of2 a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;Validate&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Validate&amp;lt;&#39;a&amp;gt; =
    | Object of
        value : Expr&amp;lt;&#39;a&amp;gt; *
        required : bool *
        proof : (&#39;a -&amp;gt; (string list option) list)
    | Array of
        value : Expr&amp;lt;&#39;a[]&amp;gt; *
        required : bool *
        proof : (&#39;a[] -&amp;gt; string Option) list *
        proveItems : (&#39;a -&amp;gt; Validate&amp;lt;&#39;a&amp;gt;)
    | Primitive of
        value : Expr&amp;lt;&#39;a&amp;gt; *
        required : bool *
        proof : (&#39;a -&amp;gt; string Option) list
    | Raw of
        value : &#39;a *
        message : string *
        proof : (&#39;a -&amp;gt; string Option) list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other F# validation libraries (that I know of).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fsharpforfunandprofit.com/posts/recipe-part2/&#34;&gt;http://fsharpforfunandprofit.com/posts/recipe-part2/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript-Style Promises in F#</title>
      <link>http://localhost:1313/2016/06/26/js_style_promises_in_fsharp/</link>
      <pubDate>Sun, 26 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2016/06/26/js_style_promises_in_fsharp/</guid>
      <description>&lt;p&gt;Working in enterprise level back end software often times I need to get
information from many different sources. When you have enough of these sources
the time it takes to get all the information can really add up. That&amp;rsquo;s when F#
&lt;code&gt;async&lt;/code&gt; work flow really comes in handy. Except, there is a gotcha.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have two sources we need to fetch data from:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let myData () = async {
    let! a = myData1 ()
    let! b = myData2 ()
    let resultA = a
    let resultB = b
    // ... do stuff
    // return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, when you look at that it looks like it should fetch the two data sources at
the same time. Well, it doesn&amp;rsquo;t. It does it one at a time, serially. It just
doesn&amp;rsquo;t block the thread while it is doing the fetching for each asynchronous
call.&lt;/p&gt;

&lt;p&gt;This is what you need to do to do it in parallel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let myData () = async {
    let! a = Async.StartChild &amp;lt;| myData1 ()
    let! b = Async.StartChild &amp;lt;| myData2 ()
    let! resultA = a
    let! resultB = b
    // ... do stuff
    // return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it is doing it at the same time! To me this feels a bit unintuitive. Enter
JavaScript-style promises. Promise objects point to data and don&amp;rsquo;t execute
until you are ready to execute them as an &lt;code&gt;async&lt;/code&gt; function does in F#.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let myData () =
    Q
    .all([myData1(), myData2()]) // Call two promises at the same time.
    .spread((resultA, resultB) =&amp;gt; {/* Do stuff here. */})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Could we do something like that in F#? We can mimic the process in F# by having
multiple functions depending on how many asynchronous processes you would like
to run at a time.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say you would like to have two asynchronous functions run at once.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Async =
    let Spread2 a b =
        async {
            let! a = Async.StartChild a
            let! b = Async.StartChild b
            let! result1 = a
            let! result2 = b
            return result1, result2
        }
        |&amp;gt; Async.RunSynchronously
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which would flow like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let myData () =
    Async.Spread2 (myData1 ()) (myData2 ())
    |&amp;gt; fun (resultA, resultB) -&amp;gt; // Do stuff here.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty close to what the JavaScript promise looked like. In my opinion this
work flow is much more intuitive and cleaner. It has a nicer flow than the
&lt;code&gt;async&lt;/code&gt; computation-style programming by not having to deal with the boiler
plate code. I could see having a few parallel functions all the way up to perhaps
&lt;code&gt;Async.Spread6&lt;/code&gt;. It would be very rare for me to ever need to call anything with
more external calls. Usually, I&amp;rsquo;m only calling two or three web services with the
rare five or six.&lt;/p&gt;

&lt;p&gt;A variation on the function above would be to add mapping functions to your parallel
function. I&amp;rsquo;m not sure if that would be useful in practice, but if it is I&amp;rsquo;ll be
adding it to mine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Async =
    let Spread2With (a, f1) (b, f2) =
        async {
            let! a = Async.StartChild a
            let! b = Async.StartChild b
            let! result1 = a
            let! result2 = b
            return (f1 result1), (f2 result2)
        }
        |&amp;gt; Async.RunSynchronously
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also debate whether it is smart to add the &lt;code&gt;Async.RunSynchronously&lt;/code&gt; at the end. If I didn&amp;rsquo;t have it I could use &lt;code&gt;Spread2&lt;/code&gt; to create &lt;code&gt;Spread4&lt;/code&gt; etc. If I ever needed more than six it might be worth it. But for now I haven&amp;rsquo;t run into that problem since I started using this pattern.&lt;/p&gt;

&lt;p&gt;Inspiration for this post:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fsharpforfunandprofit.com/posts/recipe-part2/#comment-1508742658&#34;&gt;http://fsharpforfunandprofit.com/posts/recipe-part2/#comment-1508742658&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/a/15829290/632495&#34;&gt;http://stackoverflow.com/a/15829290/632495&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>