<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>F# on JNyman.com</title>
    <link>http://jnyman.com/tags/f#/</link>
    <description>Recent content in F# on JNyman.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Feb 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://jnyman.com/tags/f#/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Power of Static Typing</title>
      <link>http://jnyman.com/2017/02/12/the_power_of_static_typing/</link>
      <pubDate>Sun, 12 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://jnyman.com/2017/02/12/the_power_of_static_typing/</guid>
      <description>From what I understand static typing makes programmers more productive and gives implicit documentation to the code base - although explicit documentation is also very helpful. It also seems to make the tools we use much more powerful.
One of the problems of static typing is that your code becomes more verbose. With programming languages like F# the compiler will implicitly type as much of your program as possible. Where it fails, you need to type it yourself.</description>
    </item>
    
    <item>
      <title>F# with Web API and Railway-Oriented Programming</title>
      <link>http://jnyman.com/2016/12/04/fsharp_with_webapi/</link>
      <pubDate>Sun, 04 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://jnyman.com/2016/12/04/fsharp_with_webapi/</guid>
      <description>I presented at the 2016 Desert Code Camp. The topic was WebAPI with F#. I also did a video series to go along with the talk. The talk and video series basically goes over how to use F# in a functional manner by building out all the pieces from scratch.
Here&amp;rsquo;s the series, hope you enjoy it!
F# WebAPI From Start to Finish.
Some set up steps and notes that are important to the success of the project:</description>
    </item>
    
    <item>
      <title>Validation in F#</title>
      <link>http://jnyman.com/2016/11/27/validation_in_fsharp/</link>
      <pubDate>Sun, 27 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://jnyman.com/2016/11/27/validation_in_fsharp/</guid>
      <description>The full code for this article is up on GitHub.
I like to the keep things as simple as possible and, ideally, reusable. At my previous employment I came up with a method of validation, but I was never entirely happy with the results. Some of the code repeated itself, and it was difficult to extend to arrays and array comparison. So, I went back to the drawing board building on top of the ideas that I created with the first validation library I created.</description>
    </item>
    
    <item>
      <title>JavaScript-Style Promises in F#</title>
      <link>http://jnyman.com/2016/06/26/js_style_promises_in_fsharp/</link>
      <pubDate>Sun, 26 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://jnyman.com/2016/06/26/js_style_promises_in_fsharp/</guid>
      <description>Working in enterprise level back end software often times I need to get information from many different sources. When you have enough of these sources the time it takes to get all the information can really add up. That&amp;rsquo;s when F# async work flow really comes in handy. Except, there is a gotcha.
Let&amp;rsquo;s say we have two sources we need to fetch data from:
let myData () = async { let!</description>
    </item>
    
  </channel>
</rss>